## Control your plant over MQTT



So far your relay is controlled by the IoT device directly based off a single soil moisture reading. In a commercial irrigation system, the control logic will be centralized, allowing it to make decisions on watering using data from multiple sensors, and allowing any configuration to be changed in one single place. To simulate this, you can control the relay over MQTT.

### Task - control the relay over MQTT



1. Add the relevant MQTT libraries/pip packages and code to your `soil-moisture-sensor` project to connect to MQTT. Name the client ID as `soilmoisturesensor_client` prefixed by your ID.

   > âš ï¸ You can refer to [the instructions for connecting to MQTT in the previous lab](https://tutors.dev/lab/iot-standards-protocols-2025/topic-02/book-2).

2. Add the relevant device code to send telemetry with the soil moisture settings. For the telemetry message, name the property `soil_moisture`.

   > âš ï¸ You can refer to [the instructions for sending telemetry to MQTT in the previous lab](https://tutors.dev/lab/iot-standards-protocols-2025/topic-02/book-2/single-board-computer-telemetry).

3. Create some local server code to subscribe to telemetry and send a command to control the relay in a folder called `soil-moisture-sensor-server`. Name the property in the command message `relay_on`, and set the client ID as `soilmoisturesensor_server` prefixed by your ID. Keep the same structure as the server code you wrote for the last lab.

   > âš ï¸ You can refer to [the instructions for subscribing to  telemetry to MQTT](https://tutors.dev/lab/iot-standards-protocols-2025/topic-02/book-2/mqtt-client#subscribe-to-telemetry) and [sending commands over MQTT](https://tutors.dev/lab/iot-standards-protocols-2025/topic-02/book-2/mqtt-client#send-commands-to-the-mqtt-broker) in the last lab. Your ``handle_telemetry`` function should be similar to this:
   > ```python
   > def handle_telemetry(client, userdata, message):
   >     payload = json.loads(message.payload.decode())
   >     print("Message received:", payload)
   >     moisture = payload['soil_moisture']
   >     command = { 'relay_on' : moisture < 200 }
   >     print("Sending message:", command)
   >     client.publish(server_command_topic, json.dumps(command))
   > ```
   >
   > Output from the server should be similar to this:
   > ```
   > message received: {'soil_moisture': 489}
   > Sending message: {'relay_on': False}
   > Message received: {'soil_moisture': 492}
   > Sending message: {'relay_on': False}
   > Message received: {'soil_moisture': 0}
   > Sending message: {'relay_on': True}
   > ```
   >
   > 

4. Add the relevant device code to control the relay from received commands, using the `relay_on` property from the message. Send true for `relay_on` if the `soil_moisture` is greater than 450, otherwise send false, the same as the logic you added for the IoT device earlier.

   > âš ï¸ You can refer to [the instructions for responding to commands from MQTT in the previous lab](https://tutors.dev/lab/iot-standards-protocols-2025/topic-02/book-2/Control%20from%20the%20Internet#control-from-the-internet).
   >
   > Your ``handle_command`` function should look like this:
   > ```python
   > def handle_command(client, userdata, message):
   >     payload = json.loads(message.payload.decode())
   >     print("Message received:", payload)
   >     if payload['relay_on']:
   >         relay.on()
   >     else:
   >         relay.off()
   > ```
   >
   > 

> ğŸ’ You can find this code in the [code-mqtt]() folder.

Make sure the code is running on your device and local server, and test it out by changing soil moisture levels, either by changing the values sent by the virtual sensor, or by changing the moisture levels of the soil by adding water or removing the sensor from the soil.