# Device Discovery

In the last step, in order to interact with the Raspberry Pi API, the client code contained the IP address. This means it needs to be updates every time the RPi gets a new IP address.

In this section, we will use an approach based on **Simple Service Discovery Protocol (SSDP)** to discover the IP address and associated end points to control the Raspberry Pi via the API.

SSDP is a text-based protocol based on HTTPU. It uses the User Datagram Protocol (UDP) as the underlying transport protocol. Services are announced by the hosting system with multicast addressing to a specifically designated IP multicast address 239.255.255.250, typically at UDP port number 1900.

You will now create a "connected button" that can discover the Raspberry Pi and interact with the API developed in the last step.

## Discovery Service
The Raspberry Pi will need to "join" the multicast group, IP: 239.255.255.250, port 5007. When a discovery request is received that matches the **Search Target(ST)**, it will respond with the API endpoint.

+ On your RPi, create a directory called ``discovery`` in the home directory. Create a python program called ``discoServer.py`` with the following contents:

~~~python
import socket
import struct
import httplib2

MCAST_GRP = '239.255.255.250'
MCAST_PORT = 5007
responseBody = '{"on":"/sensehat/light?state=on","off":"/sensehat/light?state=off", "port":5000}'

def headerValue(response, header):
    source = response.splitlines()
    for line in source:
        if line.startswith(header):
            return line[line.find(":")+1:]

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
sock.setsockopt(socket.SOL_SOCKET,  socket.SO_REUSEPORT, 1)

sock.bind((MCAST_GRP, MCAST_PORT))

mreq = struct.pack("4sl", socket.inet_aton(MCAST_GRP), socket.INADDR_ANY)

sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)


while True:
    data, address = sock.recvfrom(4096)
    data = str(data.decode('UTF-8'))
    print('Received ' + str(len(data)) + ' bytes from ' + str(address))
    if headerValue(data,"ST") == 'urn:sense_pi':
        print('responding...')
        sent = sock.sendto(responseBody.encode(), address)
~~~

+ Run the python program on the RPi. It will respond to SSDP requests that contain the following header ``ST:urn:sensepi``.

+ In a separate terminal window(or new SSH session), run the sensePi API developed in the previous steps.

## Packet Tracer Model

+ In the same Packet Tracer simulation from the last step, add the following devices and connect them as shown below:

![Connected Button](./img/1.png)

+ In the SBC1, open the programming tab  and delete the default Blink application
+ Add an empty **Python Project** called "SSDP Client".
+ Add the following to main.py 

~~~python
from realudp import *
from time import *

# HTTPU message
msg = \
    'M-SEARCH * HTTP/1.1\r\n' \
    'HOST:239.255.255.250:5007\r\n' \
    'ST:urn:sense_pi\r\n' \
    'MX:2\r\n' \
    'MAN:"ssdp:discover"\r\n' \
    '\r\n'

IP = "239.255.255.250" 
PORT = 5007
maxDiscoReq = 2
discovering = True

def onUDPReceive(ip, port, data):
	global discovering
	ip= ip.split(":")[3]
	print("received from "
		+ ip + ":" + str(port) + ":" + data);
	discovering=False
	
	
def main():
	socket = RealUDPSocket()
	socket.onReceive(onUDPReceive)
	print(socket.begin(1235))
	count = 0	
	while discovering:
		count += 1
		socket.send(IP, PORT, msg)
		sleep(1)
		if count>maxDiscoReq:
			print("Device not found.\n Exiting program.")
			exit()
	
	while True:
		sleep(1)
	

if __name__ == "__main__":
	main()
~~~

The program should discover the Raspberry Pi on your network and you should see a similar result as shown below:

~~~text
Starting SSDP Client (Python)...
True
received from 192.168.1.153:5007:{"on":"/sensehat/light?state=on","off":"/sensehat/light?state=off","port":5000}
~~~

Notice that the IP address of the Raspberry Pi is returned.
If the requests time out, then check that the discovery service is running on the Raspberry Pi and the RPi and your host with Packet Tracer are on the same network. 
The HTTPU payload contains a JSON object with the URLs to access the API running.

We will now update the program to combine this with the input from the button.

+ Add the following statements at the top of the program, just below the existing import statements:

~~~python
from gpio import *
import json
from realhttp import *

urlON = ""
urlOFF= ""
pinMode(1, IN)
http = RealHTTPClient()
~~~

+ You will handle the digital input from the button the same way as with the motion detector step. Add the following function:

~~~python
#Event Handler for digital port 1
def handleSensorData():
    motionState = digitalRead(1)
    print(motionState)
    if motionState==LOW:
        http.post(urlOFF,"")
    else:
        http.post(urlON,"")

~~~

+ Add the following statements at the end of the function **onUDPReceive(...)** to process the URL details in the payload

~~~python
	global urlON
	global urlOFF
	jsonData = json.loads(data)
	port = jsonData["port"]
	onPath = jsonData["on"]
	offPath = jsonData["off"]
	urlON='http://%s:%s/%s' % (ip, str(port), onPath)
	urlOFF='http://%s:%s/%s' % (ip, str(port), offPath)
~~~

+ Finally, in the **main()** function, add the following code to add the event handler for the connected button on port D1. Add this statement just before the ``while True:`` :

~~~python
add_event_detect(1, handleSensorData) # add event handler to port 1
~~~

+ Now click the button in the packet tracer simulation. You will see that it controls the LED matrix similar to the motion detector.

## Optional Exercises

+ If you can, change the IP address of the Raspberry Pi, restart the API and Discovery service,  and try both the Motion Detector and the Button again. Notice that the button will still work but you will need to update the Motion Detector program.
+ Update the code so that the LEDs will always be on when the button is pushed down (state == HIGH). 